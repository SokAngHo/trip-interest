{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./public/js/index.js","webpack:///./public/js/modules/map.js","webpack:///./public/js/modules/RouteBoxer.js"],"names":["initMap","autocomplete","document","getElementById","map","directionsService","directionsRenderer","placesService","routeBoxer","google","maps","Map","center","lat","lng","zoom","DirectionsService","DirectionsRenderer","places","PlacesService","setMap","RouteBoxer","drawRoutes","textInput","placeIdInput","dropdown","Autocomplete","addListener","place","getPlace","value","place_id","addEventListener","e","keyCode","preventDefault","route","origin","placeId","destination","travelMode","res","status","routes","path","overview_path","distance","legs","boxes","box","drawBoxes","setDirections","console","log","boxpolys","Array","length","i","Rectangle","bounds","fillOpacity","strokeOpacity","strokeColor","strokeWeight","R","prototype","range","grid_","latGrid_","lngGrid_","boxesX_","boxesY_","vertices","Polyline","getPath","getLength","getAt","getVertexCount","j","getVertex","buildGrid_","findIntersectingCells_","mergeIntersectingCells_","routeBounds","LatLngBounds","extend","routeBoundsCenter","getCenter","push","rhumbDestinationPoint","getNorthEast","getSouthWest","unshift","hintXY","getCellCoords_","markCell_","gridXY","getGridCoordsFromHint_","Math","abs","getGridIntersects_","latlng","x","y","hintlatlng","hint","start","end","startXY","endXY","edgePoint","edgeXY","brng","rhumbBearingTo","getGridIntersect_","fillInGridSquares_","gridLineLat","d","toRad","cos","startx","endx","cell","currentBox","getCellBounds_","mergeBoxesY_","mergeBoxesX_","LatLng","dist","parseFloat","lat1","lon1","lat2","dLat","dPhi","tan","PI","q","dLon","sin","lon2","isNaN","toDeg","dest","atan2","toBrng","Number"],"mappings":"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","file":"App.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { initMap, autocomplete } from './modules/map';\n\ninitMap();\n\n// Setup places auto completion on origin and destination inputs.\nautocomplete(document.getElementById('orig-text-input'), document.getElementById('orig-id'));\nautocomplete(document.getElementById('dest-text-input'), document.getElementById('dest-id'));\n","import { RouteBoxer } from './RouteBoxer';\n\nlet map;\nlet directionsService;\nlet directionsRenderer;\nlet placesService;\nlet routeBoxer;\n\nexport function initMap() {\n  // Initilise map to Melbourne location\n  map = new google.maps.Map(document.getElementById('map'), {\n    center: { lat: -37.8136, lng: 144.9631 },\n    zoom: 8,\n  });\n  directionsService = new google.maps.DirectionsService();\n  directionsRenderer = new google.maps.DirectionsRenderer();\n  placesService = new google.maps.places.PlacesService(map);\n  directionsRenderer.setMap(map);\n  routeBoxer = new RouteBoxer();\n\n  // Draw routes on the map\n  drawRoutes(directionsService, directionsRenderer);\n}\n\n// Google Map places auto completion on input\nexport function autocomplete(textInput, placeIdInput) {\n  if (!textInput) return;\n\n  const dropdown = new google.maps.places.Autocomplete(textInput);\n  dropdown.addListener('place_changed', () => {\n    const place = dropdown.getPlace();\n    placeIdInput.value = place.place_id;\n  });\n\n  textInput.addEventListener('keydown', (e) => {\n    if (e.keyCode === 13) e.preventDefault();\n  });\n}\n\nfunction drawRoutes(directionsService, directionsRenderer) {\n  directionsService.route(\n    {\n      origin: { placeId: document.getElementById('orig-id').value },\n      destination: { placeId: document.getElementById('dest-id').value },\n      travelMode: 'DRIVING',\n    },\n    function (res, status) {\n      if (status === 'OK') {\n        const route = res.routes[0];\n        const path = route.overview_path;\n        const distance = route.legs[0].distance.value / 15000;\n        const boxes = routeBoxer.box(path, distance);\n        drawBoxes(boxes);\n        directionsRenderer.setDirections(res);\n      } else {\n        console.log(status);\n      }\n    }\n  );\n}\n\nfunction drawBoxes(boxes) {\n  var boxpolys = new Array(boxes.length);\n  for (var i = 0; i < boxes.length; i++) {\n    boxpolys[i] = new google.maps.Rectangle({\n      bounds: boxes[i],\n      fillOpacity: 0,\n      strokeOpacity: 1.0,\n      strokeColor: '#000000',\n      strokeWeight: 1,\n      map: map,\n    });\n  }\n}\n","/**\n * This file is retreived from\n * https://github.com/googlemaps/v3-utility-library/blob/master/archive/routeboxer/src/RouteBoxer.js\n *\n * @name RouteBoxer\n * @version 1.0\n * @copyright (c) 2010 Google Inc.\n * @author Thor Mitchell\n *\n * @fileoverview The RouteBoxer class takes a path, such as the Polyline for a\n * route generated by a Directions request, and generates a set of LatLngBounds\n * objects that are guaranteed to contain every point within a given distance\n * of that route. These LatLngBounds objects can then be used to generate\n * requests to spatial search services that support bounds filtering (such as\n * the Google Maps Data API) in order to implement search along a route.\n * <br/><br/>\n * RouteBoxer overlays a grid of the specified size on the route, identifies\n * every grid cell that the route passes through, and generates a set of bounds\n * that cover all of these cells, and their nearest neighbours. Consequently\n * the bounds returned will extend up to ~3x the specified distance from the\n * route in places.\n */\n\n/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Creates a new RouteBoxer\n *\n * @constructor\n */\nexport function RouteBoxer() {\n  this.R = 6371; // earth's mean radius in km\n}\n\n/**\n * Generates boxes for a given route and distance\n *\n * @param {google.maps.LatLng[] | google.maps.Polyline} path The path along\n *           which to create boxes. The path object can be either an Array of\n *           google.maps.LatLng objects or a Maps API v2 or Maps API v3\n *           google.maps.Polyline object.\n * @param {Number} range The distance in kms around the route that the generated\n *           boxes must cover.\n * @return {google.maps.LatLngBounds[]} An array of boxes that covers the whole\n *           path.\n */\nRouteBoxer.prototype.box = function (path, range) {\n  // Two dimensional array representing the cells in the grid overlaid on the path\n  this.grid_ = null;\n\n  // Array that holds the latitude coordinate of each vertical grid line\n  this.latGrid_ = [];\n\n  // Array that holds the longitude coordinate of each horizontal grid line\n  this.lngGrid_ = [];\n\n  // Array of bounds that cover the whole route formed by merging cells that\n  //  the route intersects first horizontally, and then vertically\n  this.boxesX_ = [];\n\n  // Array of bounds that cover the whole route formed by merging cells that\n  //  the route intersects first vertically, and then horizontally\n  this.boxesY_ = [];\n\n  // The array of LatLngs representing the vertices of the path\n  var vertices = null;\n\n  // If necessary convert the path into an array of LatLng objects\n  if (path instanceof Array) {\n    // already an arry of LatLngs (eg. v3 overview_path)\n    vertices = path;\n  } else if (path instanceof google.maps.Polyline) {\n    if (path.getPath) {\n      // v3 Maps API Polyline object\n      vertices = new Array(path.getPath().getLength());\n      for (var i = 0; i < vertices.length; i++) {\n        vertices[i] = path.getPath().getAt(i);\n      }\n    } else {\n      // v2 Maps API Polyline object\n      vertices = new Array(path.getVertexCount());\n      for (var j = 0; j < vertices.length; j++) {\n        vertices[j] = path.getVertex(j);\n      }\n    }\n  }\n\n  // Build the grid that is overlaid on the route\n  this.buildGrid_(vertices, range);\n\n  // Identify the grid cells that the route intersects\n  this.findIntersectingCells_(vertices);\n\n  // Merge adjacent intersected grid cells (and their neighbours) into two sets\n  //  of bounds, both of which cover them completely\n  this.mergeIntersectingCells_();\n\n  // Return the set of merged bounds that has the fewest elements\n  return this.boxesX_.length <= this.boxesY_.length ? this.boxesX_ : this.boxesY_;\n};\n\n/**\n * Generates boxes for a given route and distance\n *\n * @param {LatLng[]} vertices The vertices of the path over which to lay the grid\n * @param {Number} range The spacing of the grid cells.\n */\nRouteBoxer.prototype.buildGrid_ = function (vertices, range) {\n  // Create a LatLngBounds object that contains the whole path\n  var routeBounds = new google.maps.LatLngBounds();\n  for (var i = 0; i < vertices.length; i++) {\n    routeBounds.extend(vertices[i]);\n  }\n\n  // Find the center of the bounding box of the path\n  var routeBoundsCenter = routeBounds.getCenter();\n\n  // Starting from the center define grid lines outwards vertically until they\n  //  extend beyond the edge of the bounding box by more than one cell\n  this.latGrid_.push(routeBoundsCenter.lat());\n\n  // Add lines from the center out to the north\n  this.latGrid_.push(routeBoundsCenter.rhumbDestinationPoint(0, range).lat());\n  for (i = 2; this.latGrid_[i - 2] < routeBounds.getNorthEast().lat(); i++) {\n    this.latGrid_.push(routeBoundsCenter.rhumbDestinationPoint(0, range * i).lat());\n  }\n\n  // Add lines from the center out to the south\n  for (i = 1; this.latGrid_[1] > routeBounds.getSouthWest().lat(); i++) {\n    this.latGrid_.unshift(routeBoundsCenter.rhumbDestinationPoint(180, range * i).lat());\n  }\n\n  // Starting from the center define grid lines outwards horizontally until they\n  //  extend beyond the edge of the bounding box by more than one cell\n  this.lngGrid_.push(routeBoundsCenter.lng());\n\n  // Add lines from the center out to the east\n  this.lngGrid_.push(routeBoundsCenter.rhumbDestinationPoint(90, range).lng());\n  for (i = 2; this.lngGrid_[i - 2] < routeBounds.getNorthEast().lng(); i++) {\n    this.lngGrid_.push(routeBoundsCenter.rhumbDestinationPoint(90, range * i).lng());\n  }\n\n  // Add lines from the center out to the west\n  for (i = 1; this.lngGrid_[1] > routeBounds.getSouthWest().lng(); i++) {\n    this.lngGrid_.unshift(routeBoundsCenter.rhumbDestinationPoint(270, range * i).lng());\n  }\n\n  // Create a two dimensional array representing this grid\n  this.grid_ = new Array(this.lngGrid_.length);\n  for (i = 0; i < this.grid_.length; i++) {\n    this.grid_[i] = new Array(this.latGrid_.length);\n  }\n};\n\n/**\n * Find all of the cells in the overlaid grid that the path intersects\n *\n * @param {LatLng[]} vertices The vertices of the path\n */\nRouteBoxer.prototype.findIntersectingCells_ = function (vertices) {\n  // Find the cell where the path begins\n  var hintXY = this.getCellCoords_(vertices[0]);\n\n  // Mark that cell and it's neighbours for inclusion in the boxes\n  this.markCell_(hintXY);\n\n  // Work through each vertex on the path identifying which grid cell it is in\n  for (var i = 1; i < vertices.length; i++) {\n    // Use the known cell of the previous vertex to help find the cell of this vertex\n    var gridXY = this.getGridCoordsFromHint_(vertices[i], vertices[i - 1], hintXY);\n\n    if (gridXY[0] === hintXY[0] && gridXY[1] === hintXY[1]) {\n      // This vertex is in the same cell as the previous vertex\n      // The cell will already have been marked for inclusion in the boxes\n      continue;\n    } else if (\n      (Math.abs(hintXY[0] - gridXY[0]) === 1 && hintXY[1] === gridXY[1]) ||\n      (hintXY[0] === gridXY[0] && Math.abs(hintXY[1] - gridXY[1]) === 1)\n    ) {\n      // This vertex is in a cell that shares an edge with the previous cell\n      // Mark this cell and it's neighbours for inclusion in the boxes\n      this.markCell_(gridXY);\n    } else {\n      // This vertex is in a cell that does not share an edge with the previous\n      //  cell. This means that the path passes through other cells between\n      //  this vertex and the previous vertex, and we must determine which cells\n      //  it passes through\n      this.getGridIntersects_(vertices[i - 1], vertices[i], hintXY, gridXY);\n    }\n\n    // Use this cell to find and compare with the next one\n    hintXY = gridXY;\n  }\n};\n\n/**\n * Find the cell a path vertex is in by brute force iteration over the grid\n *\n * @param {LatLng[]} latlng The latlng of the vertex\n * @return {Number[][]} The cell coordinates of this vertex in the grid\n */\nRouteBoxer.prototype.getCellCoords_ = function (latlng) {\n  for (var x = 0; this.lngGrid_[x] < latlng.lng(); x++) {}\n  for (var y = 0; this.latGrid_[y] < latlng.lat(); y++) {}\n  return [x - 1, y - 1];\n};\n\n/**\n * Find the cell a path vertex is in based on the known location of a nearby\n *  vertex. This saves searching the whole grid when working through vertices\n *  on the polyline that are likely to be in close proximity to each other.\n *\n * @param {LatLng[]} latlng The latlng of the vertex to locate in the grid\n * @param {LatLng[]} hintlatlng The latlng of the vertex with a known location\n * @param {Number[]} hint The cell containing the vertex with a known location\n * @return {Number[]} The cell coordinates of the vertex to locate in the grid\n */\nRouteBoxer.prototype.getGridCoordsFromHint_ = function (latlng, hintlatlng, hint) {\n  var x, y;\n  if (latlng.lng() > hintlatlng.lng()) {\n    for (x = hint[0]; this.lngGrid_[x + 1] < latlng.lng(); x++) {}\n  } else {\n    for (x = hint[0]; this.lngGrid_[x] > latlng.lng(); x--) {}\n  }\n\n  if (latlng.lat() > hintlatlng.lat()) {\n    for (y = hint[1]; this.latGrid_[y + 1] < latlng.lat(); y++) {}\n  } else {\n    for (y = hint[1]; this.latGrid_[y] > latlng.lat(); y--) {}\n  }\n\n  return [x, y];\n};\n\n/**\n * Identify the grid squares that a path segment between two vertices\n * intersects with by:\n * 1. Finding the bearing between the start and end of the segment\n * 2. Using the delta between the lat of the start and the lat of each\n *    latGrid boundary to find the distance to each latGrid boundary\n * 3. Finding the lng of the intersection of the line with each latGrid\n *     boundary using the distance to the intersection and bearing of the line\n * 4. Determining the x-coord on the grid of the point of intersection\n * 5. Filling in all squares between the x-coord of the previous intersection\n *     (or start) and the current one (or end) at the current y coordinate,\n *     which is known for the grid line being intersected\n *\n * @param {LatLng} start The latlng of the vertex at the start of the segment\n * @param {LatLng} end The latlng of the vertex at the end of the segment\n * @param {Number[]} startXY The cell containing the start vertex\n * @param {Number[]} endXY The cell containing the vend vertex\n */\nRouteBoxer.prototype.getGridIntersects_ = function (start, end, startXY, endXY) {\n  var edgePoint, edgeXY, i;\n  var brng = start.rhumbBearingTo(end); // Step 1.\n\n  var hint = start;\n  var hintXY = startXY;\n\n  // Handle a line segment that travels south first\n  if (end.lat() > start.lat()) {\n    // Iterate over the east to west grid lines between the start and end cells\n    for (i = startXY[1] + 1; i <= endXY[1]; i++) {\n      // Find the latlng of the point where the path segment intersects with\n      //  this grid line (Step 2 & 3)\n      edgePoint = this.getGridIntersect_(start, brng, this.latGrid_[i]);\n\n      // Find the cell containing this intersect point (Step 4)\n      edgeXY = this.getGridCoordsFromHint_(edgePoint, hint, hintXY);\n\n      // Mark every cell the path has crossed between this grid and the start,\n      //   or the previous east to west grid line it crossed (Step 5)\n      this.fillInGridSquares_(hintXY[0], edgeXY[0], i - 1);\n\n      // Use the point where it crossed this grid line as the reference for the\n      //  next iteration\n      hint = edgePoint;\n      hintXY = edgeXY;\n    }\n\n    // Mark every cell the path has crossed between the last east to west grid\n    //  line it crossed and the end (Step 5)\n    this.fillInGridSquares_(hintXY[0], endXY[0], i - 1);\n  } else {\n    // Iterate over the east to west grid lines between the start and end cells\n    for (i = startXY[1]; i > endXY[1]; i--) {\n      // Find the latlng of the point where the path segment intersects with\n      //  this grid line (Step 2 & 3)\n      edgePoint = this.getGridIntersect_(start, brng, this.latGrid_[i]);\n\n      // Find the cell containing this intersect point (Step 4)\n      edgeXY = this.getGridCoordsFromHint_(edgePoint, hint, hintXY);\n\n      // Mark every cell the path has crossed between this grid and the start,\n      //   or the previous east to west grid line it crossed (Step 5)\n      this.fillInGridSquares_(hintXY[0], edgeXY[0], i);\n\n      // Use the point where it crossed this grid line as the reference for the\n      //  next iteration\n      hint = edgePoint;\n      hintXY = edgeXY;\n    }\n\n    // Mark every cell the path has crossed between the last east to west grid\n    //  line it crossed and the end (Step 5)\n    this.fillInGridSquares_(hintXY[0], endXY[0], i);\n  }\n};\n\n/**\n * Find the latlng at which a path segment intersects with a given\n *   line of latitude\n *\n * @param {LatLng} start The vertex at the start of the path segment\n * @param {Number} brng The bearing of the line from start to end\n * @param {Number} gridLineLat The latitude of the grid line being intersected\n * @return {LatLng} The latlng of the point where the path segment intersects\n *                    the grid line\n */\nRouteBoxer.prototype.getGridIntersect_ = function (start, brng, gridLineLat) {\n  var d = this.R * ((gridLineLat.toRad() - start.lat().toRad()) / Math.cos(brng.toRad()));\n  return start.rhumbDestinationPoint(brng, d);\n};\n\n/**\n * Mark all cells in a given row of the grid that lie between two columns\n *   for inclusion in the boxes\n *\n * @param {Number} startx The first column to include\n * @param {Number} endx The last column to include\n * @param {Number} y The row of the cells to include\n */\nRouteBoxer.prototype.fillInGridSquares_ = function (startx, endx, y) {\n  var x;\n  if (startx < endx) {\n    for (x = startx; x <= endx; x++) {\n      this.markCell_([x, y]);\n    }\n  } else {\n    for (x = startx; x >= endx; x--) {\n      this.markCell_([x, y]);\n    }\n  }\n};\n\n/**\n * Mark a cell and the 8 immediate neighbours for inclusion in the boxes\n *\n * @param {Number[]} square The cell to mark\n */\nRouteBoxer.prototype.markCell_ = function (cell) {\n  var x = cell[0];\n  var y = cell[1];\n  this.grid_[x - 1][y - 1] = 1;\n  this.grid_[x][y - 1] = 1;\n  this.grid_[x + 1][y - 1] = 1;\n  this.grid_[x - 1][y] = 1;\n  this.grid_[x][y] = 1;\n  this.grid_[x + 1][y] = 1;\n  this.grid_[x - 1][y + 1] = 1;\n  this.grid_[x][y + 1] = 1;\n  this.grid_[x + 1][y + 1] = 1;\n};\n\n/**\n * Create two sets of bounding boxes, both of which cover all of the cells that\n *   have been marked for inclusion.\n *\n * The first set is created by combining adjacent cells in the same column into\n *   a set of vertical rectangular boxes, and then combining boxes of the same\n *   height that are adjacent horizontally.\n *\n * The second set is created by combining adjacent cells in the same row into\n *   a set of horizontal rectangular boxes, and then combining boxes of the same\n *   width that are adjacent vertically.\n *\n */\nRouteBoxer.prototype.mergeIntersectingCells_ = function () {\n  var x, y, box;\n\n  // The box we are currently expanding with new cells\n  var currentBox = null;\n\n  // Traverse the grid a row at a time\n  for (y = 0; y < this.grid_[0].length; y++) {\n    for (x = 0; x < this.grid_.length; x++) {\n      if (this.grid_[x][y]) {\n        // This cell is marked for inclusion. If the previous cell in this\n        //   row was also marked for inclusion, merge this cell into it's box.\n        // Otherwise start a new box.\n        box = this.getCellBounds_([x, y]);\n        if (currentBox) {\n          currentBox.extend(box.getNorthEast());\n        } else {\n          currentBox = box;\n        }\n      } else {\n        // This cell is not marked for inclusion. If the previous cell was\n        //  marked for inclusion, merge it's box with a box that spans the same\n        //  columns from the row below if possible.\n        this.mergeBoxesY_(currentBox);\n        currentBox = null;\n      }\n    }\n    // If the last cell was marked for inclusion, merge it's box with a matching\n    //  box from the row below if possible.\n    this.mergeBoxesY_(currentBox);\n    currentBox = null;\n  }\n\n  // Traverse the grid a column at a time\n  for (x = 0; x < this.grid_.length; x++) {\n    for (y = 0; y < this.grid_[0].length; y++) {\n      if (this.grid_[x][y]) {\n        // This cell is marked for inclusion. If the previous cell in this\n        //   column was also marked for inclusion, merge this cell into it's box.\n        // Otherwise start a new box.\n        if (currentBox) {\n          box = this.getCellBounds_([x, y]);\n          currentBox.extend(box.getNorthEast());\n        } else {\n          currentBox = this.getCellBounds_([x, y]);\n        }\n      } else {\n        // This cell is not marked for inclusion. If the previous cell was\n        //  marked for inclusion, merge it's box with a box that spans the same\n        //  rows from the column to the left if possible.\n        this.mergeBoxesX_(currentBox);\n        currentBox = null;\n      }\n    }\n    // If the last cell was marked for inclusion, merge it's box with a matching\n    //  box from the column to the left if possible.\n    this.mergeBoxesX_(currentBox);\n    currentBox = null;\n  }\n};\n\n/**\n * Search for an existing box in an adjacent row to the given box that spans the\n * same set of columns and if one is found merge the given box into it. If one\n * is not found, append this box to the list of existing boxes.\n *\n * @param {LatLngBounds}  The box to merge\n */\nRouteBoxer.prototype.mergeBoxesX_ = function (box) {\n  if (box !== null) {\n    for (var i = 0; i < this.boxesX_.length; i++) {\n      if (\n        this.boxesX_[i].getNorthEast().lng() === box.getSouthWest().lng() &&\n        this.boxesX_[i].getSouthWest().lat() === box.getSouthWest().lat() &&\n        this.boxesX_[i].getNorthEast().lat() === box.getNorthEast().lat()\n      ) {\n        this.boxesX_[i].extend(box.getNorthEast());\n        return;\n      }\n    }\n    this.boxesX_.push(box);\n  }\n};\n\n/**\n * Search for an existing box in an adjacent column to the given box that spans\n * the same set of rows and if one is found merge the given box into it. If one\n * is not found, append this box to the list of existing boxes.\n *\n * @param {LatLngBounds}  The box to merge\n */\nRouteBoxer.prototype.mergeBoxesY_ = function (box) {\n  if (box !== null) {\n    for (var i = 0; i < this.boxesY_.length; i++) {\n      if (\n        this.boxesY_[i].getNorthEast().lat() === box.getSouthWest().lat() &&\n        this.boxesY_[i].getSouthWest().lng() === box.getSouthWest().lng() &&\n        this.boxesY_[i].getNorthEast().lng() === box.getNorthEast().lng()\n      ) {\n        this.boxesY_[i].extend(box.getNorthEast());\n        return;\n      }\n    }\n    this.boxesY_.push(box);\n  }\n};\n\n/**\n * Obtain the LatLng of the origin of a cell on the grid\n *\n * @param {Number[]} cell The cell to lookup.\n * @return {LatLng} The latlng of the origin of the cell.\n */\nRouteBoxer.prototype.getCellBounds_ = function (cell) {\n  return new google.maps.LatLngBounds(\n    new google.maps.LatLng(this.latGrid_[cell[1]], this.lngGrid_[cell[0]]),\n    new google.maps.LatLng(this.latGrid_[cell[1] + 1], this.lngGrid_[cell[0] + 1])\n  );\n};\n\n/* Based on the Latitude/longitude spherical geodesy formulae & scripts\n   at http://www.movable-type.co.uk/scripts/latlong.html\n   (c) Chris Veness 2002-2010\n*/\ngoogle.maps.LatLng.prototype.rhumbDestinationPoint = function (brng, dist) {\n  var R = 6371; // earth's mean radius in km\n  var d = parseFloat(dist) / R; // d = angular distance covered on earth's surface\n  var lat1 = this.lat().toRad(),\n    lon1 = this.lng().toRad();\n  brng = brng.toRad();\n\n  var lat2 = lat1 + d * Math.cos(brng);\n  var dLat = lat2 - lat1;\n  var dPhi = Math.log(Math.tan(lat2 / 2 + Math.PI / 4) / Math.tan(lat1 / 2 + Math.PI / 4));\n  var q = Math.abs(dLat) > 1e-10 ? dLat / dPhi : Math.cos(lat1);\n  var dLon = (d * Math.sin(brng)) / q;\n  // check for going past the pole\n  if (Math.abs(lat2) > Math.PI / 2) {\n    lat2 = lat2 > 0 ? Math.PI - lat2 : -(Math.PI - lat2);\n  }\n  var lon2 = ((lon1 + dLon + Math.PI) % (2 * Math.PI)) - Math.PI;\n\n  if (isNaN(lat2) || isNaN(lon2)) {\n    return null;\n  }\n  return new google.maps.LatLng(lat2.toDeg(), lon2.toDeg());\n};\n\ngoogle.maps.LatLng.prototype.rhumbBearingTo = function (dest) {\n  var dLon = (dest.lng() - this.lng()).toRad();\n  var dPhi = Math.log(\n    Math.tan(dest.lat().toRad() / 2 + Math.PI / 4) / Math.tan(this.lat().toRad() / 2 + Math.PI / 4)\n  );\n  if (Math.abs(dLon) > Math.PI) {\n    dLon = dLon > 0 ? -(2 * Math.PI - dLon) : 2 * Math.PI + dLon;\n  }\n  return Math.atan2(dLon, dPhi).toBrng();\n};\n\n/**\n * Extend the Number object to convert degrees to radians\n *\n * @return {Number} Bearing in radians\n * @ignore\n */\nNumber.prototype.toRad = function () {\n  return (this * Math.PI) / 180;\n};\n\n/**\n * Extend the Number object to convert radians to degrees\n *\n * @return {Number} Bearing in degrees\n * @ignore\n */\nNumber.prototype.toDeg = function () {\n  return (this * 180) / Math.PI;\n};\n\n/**\n * Normalize a heading in degrees to between 0 and +360\n *\n * @return {Number} Return\n * @ignore\n */\nNumber.prototype.toBrng = function () {\n  return (this.toDeg() + 360) % 360;\n};\n"],"sourceRoot":""}